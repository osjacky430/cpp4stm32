/**
 * @file  detail/algorithm.hxx
 * @brief	Constexpr version of algorithm library for c++17
 */

/** Copyright (c) 2020 by osjacky430.
 * All Rights Reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the Lesser GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Lesser GNU General Public License for more details.
 *
 * You should have received a copy of the Lesser GNU General Public License
 *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <array>
#include <functional>
#include <iterator>
#include <utility>

/**
 * @namespace 	cpp_stm32::detail
 * @brief				Detail implementation namespace
 *
 * @note 				DO NOT USE DETAIL NAMESPACE
 */
namespace cpp_stm32::detail {

/**
 *	@brief Assigns value, generated by given function object g, to the furst count elements in the range beginning at
 * 				 first, if count > 0. Does nothing otherwise.
 *
 * 	@param	first 	The beginning of the range of elements to generate
 * 	@param	count 	Number of the elements to generate
 * 	@param  g 			Generator function object that will be called
 */
template <class OutputIt, class Size, class Generator>
constexpr OutputIt generate_n(OutputIt first, Size count, Generator g) {
	for (Size i = 0; i < count; i++) {
		*first++ = g();
	}
	return first;
}

/**
 *
 */
template <class InputIt, class UnaryFunction>
constexpr UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f) {
	for (; first != last; ++first) {
		f(*first);
	}
	return f;
}

/**
 * [iota description]
 * @param first [description]
 * @param last  [description]
 * @param value [description]
 */
template <class ForwardIt, class T>
constexpr void iota(ForwardIt first, ForwardIt last, T value) {
	while (first != last) {
		*first++ = value;
		++value;
	}
}

/**
 * [generate description]
 * @param first [description]
 * @param last  [description]
 * @param g     [description]
 */
template <class ForwardIt, class Generator>
constexpr void generate(ForwardIt first, ForwardIt last, Generator g) {
	while (first != last) {
		*first++ = g();
	}
}

template <class T, std::size_t Size, typename UnaryPredicate>
constexpr auto array_count_if(std::array<T, Size> const& t_arr, UnaryPredicate const p) {
	int ret = 0;
	for (int i = 0; i < Size; ++i) {
		if (p(t_arr[i])) {
			ret++;
		}
	}

	return ret;
}

/**
 * [array_count description]
 * @param  t_arr [description]
 * @param  t_val [description]
 * @return       [description]
 */
template <class T, std::size_t Size>
constexpr auto array_count(std::array<T, Size> const& t_arr, T const& t_val) {
	int ret = 0;
	for (int i = 0; i < Size; ++i) {
		if (t_arr[i] == t_val) {
			ret++;
		}
	}

	return ret;
}

/**
 * [count description]
 * @param  first [description]
 * @param  last  [description]
 * @param  value [description]
 * @return       [description]
 */
template <class InputIt, class T>
constexpr auto count(InputIt first, InputIt last, const T& value) {
	typename std::iterator_traits<InputIt>::difference_type ret = 0;
	for (; first != last; ++first) {
		if (*first == value) {
			ret++;
		}
	}
	return ret;
}

/**
 * [find description]
 * @param  first [description]
 * @param  last  [description]
 * @param  value [description]
 * @return       [description]
 */
template <class InputIt, class T>
constexpr InputIt find(InputIt first, InputIt last, const T& value) {
	for (; first != last; ++first) {
		if (*first == value) {
			return first;
		}
	}
	return last;
}

/**
 * [find_if description]
 * @param  first [description]
 * @param  last  [description]
 * @param  p     [description]
 * @return       [description]
 */
template <class InputIt, class UnaryPredicate>
constexpr InputIt find_if(InputIt first, InputIt last, UnaryPredicate p) {
	for (; first != last; ++first) {
		if (p(*first)) {
			return first;
		}
	}
	return last;
}

/**
 * [all_of description]
 * @param  first [description]
 * @param  last  [description]
 * @param  p     [description]
 * @return       [description]
 */
template <class InputIt, class UnaryPredicate>
constexpr bool all_of(InputIt first, InputIt last, UnaryPredicate p) {
	return std::find_if_not(first, last, p) == last;
}

/**
 * [unique description]
 * @param  first [description]
 * @param  last  [description]
 * @return       [description]
 */
template <class ForwardIt>
constexpr ForwardIt unique(ForwardIt first, ForwardIt last) {
	if (first == last) {
		return last;
	}

	ForwardIt result = first;
	while (++first != last) {
		if (!(*result == *first) && ++result != first) {
			*result = std::move(*first);
		}
	}
	return ++result;
}

/**
 * [fill description]
 * @param first [description]
 * @param last  [description]
 * @param value [description]
 */
template <class ForwardIt, class T>
constexpr void fill(ForwardIt first, ForwardIt last, T const& value) {
	for (; first != last; ++first) {
		*first = value;
	}
}

/**
 * [copy description]
 * @param  first   [description]
 * @param  last    [description]
 * @param  d_first [description]
 * @return         [description]
 */
template <class InputIt, class OutputIt>
constexpr OutputIt copy(InputIt first, InputIt last, OutputIt d_first) {
	while (first != last) {
		*d_first++ = *first++;
	}
	return d_first;
}

/**
 * @ref https://tristanbrindle.com/posts/a-more-useful-compile-time-quicksort
 */
template <class InputIt, class UnaryPredicate>
constexpr InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate q) {
	for (; first != last; ++first) {
		if (!q(*first)) {
			return first;
		}
	}
	return last;
}

/**
 * [iter_swap description]
 * @param a [description]
 * @param b [description]
 */
template <class ForwardIt1, class ForwardIt2>
constexpr void iter_swap(ForwardIt1 a, ForwardIt2 b) {
	auto temp = std::move(*a);
	*a				= std::move(*b);
	*b				= std::move(temp);
}

/**
 * [partition description]
 * @param  first [description]
 * @param  last  [description]
 * @param  p     [description]
 * @return       [description]
 */
template <class ForwardIt, class UnaryPredicate>
constexpr ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate p) {
	first = detail::find_if_not(first, last, p);
	if (first == last) {
		return first;
	}

	for (ForwardIt i = first + 1; i != last; ++i) {
		if (p(*i)) {
			detail::iter_swap(i, first);
			++first;
		}
	}
	return first;
}

/**
 * [quick_sort description]
 * @param first [description]
 * @param last  [description]
 * @param cmp   [description]
 */
template <class RAIt, class Compare = std::less<>>
constexpr void quick_sort(RAIt first, RAIt last, Compare cmp = Compare{}) {
	auto const N = last - first;
	if (N <= 1) return;
	auto const pivot	 = *(first + N / 2);
	auto const middle1 = detail::partition(first, last, [=](auto const& elem) { return cmp(elem, pivot); });
	auto const middle2 = detail::partition(middle1, last, [=](auto const& elem) { return !cmp(pivot, elem); });
	quick_sort(first, middle1, cmp);
	quick_sort(middle2, last, cmp);
}

/**
 * [sort description]
 * @param  range [description]
 * @param  cmp   [description]
 * @return       [description]
 */
template <typename Range, class Compare = std::less<>>
constexpr auto sort(Range&& range, Compare cmp = Compare{}) {
	quick_sort(std::begin(range), std::end(range), cmp);
	return range;
}

/**
 * @ref https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2177
 */
template <class BinaryPredicate, class InputIt, class OutputIt>
constexpr OutputIt unique_copy(InputIt first, InputIt last, OutputIt result, BinaryPredicate pred) {
	if (first != last) {
		typename std::iterator_traits<InputIt>::value_type t(*first);
		*result = t;
		++result;
		while (++first != last) {
			if (!pred(t, *first)) {
				t				= *first;
				*result = t;
				++result;
			}
		}
	}
	return result;
}

/**
 * [lower_bound description]
 * @param  first [description]
 * @param  last  [description]
 * @param  value [description]
 * @param  comp  [description]
 * @return       [description]
 */
template <class ForwardIt, class T, class Compare>
constexpr ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp) {
	ForwardIt it;
	typename std::iterator_traits<ForwardIt>::difference_type dist, step;
	dist = std::distance(first, last);

	while (dist > 0) {
		it	 = first;
		step = dist / 2;
		std::advance(it, step);
		if (comp(*it, value)) {
			first = ++it;
			dist -= step + 1;
		} else
			dist = step;
	}
	return first;
}

/**
 * [upper_bound description]
 * @param  first [description]
 * @param  last  [description]
 * @param  value [description]
 * @param  comp  [description]
 * @return       [description]
 */
template <class ForwardIt, class T, class Compare>
constexpr ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp) {
	ForwardIt it{};
	typename std::iterator_traits<ForwardIt>::difference_type dist = std::distance(first, last);
	typename std::iterator_traits<ForwardIt>::difference_type step = 0;

	while (dist > 0) {
		it	 = first;
		step = dist / 2;
		std::advance(it, step);
		if (!comp(value, *it)) {
			first = ++it;
			dist -= step + 1;
		} else
			dist = step;
	}
	return first;
}

}	// namespace cpp_stm32::detail
